/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * Help.java
 *
 * Created on Sep 30, 2009, 4:58:52 PM
 */

/**
 *
 * @author Jubin
 */
public class Help extends javax.swing.JFrame {

    /** Creates new form Help */
    public Help() {
        initComponents();
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        jTabbedPane2 = new javax.swing.JTabbedPane();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();
        jScrollPane2 = new javax.swing.JScrollPane();
        jTextArea2 = new javax.swing.JTextArea();
        jScrollPane3 = new javax.swing.JScrollPane();
        jTextArea3 = new javax.swing.JTextArea();
        jScrollPane4 = new javax.swing.JScrollPane();
        jTextArea4 = new javax.swing.JTextArea();
        jScrollPane5 = new javax.swing.JScrollPane();
        jTextArea5 = new javax.swing.JTextArea();
        jButton1 = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("Help ");
        setBounds(new java.awt.Rectangle(30, 5, 500, 500));

        jLabel1.setForeground(new java.awt.Color(102, 0, 255));
        jLabel1.setText("8085 INSTRUCTION SET ");
        jLabel1.setName("jLabel1"); // NOI18N

        jTabbedPane2.setTabPlacement(javax.swing.JTabbedPane.LEFT);
        jTabbedPane2.setName("jTabbedPane2"); // NOI18N

        jScrollPane1.setName("jScrollPane1"); // NOI18N

        jTextArea1.setColumns(20);
        jTextArea1.setEditable(false);
        jTextArea1.setFont(new java.awt.Font("Monospaced", 1, 13));
        jTextArea1.setRows(5);
        jTextArea1.setText("Opcode      Operand                    Description \n\nCopy from source to destination \nMOV         Rd, Rs                     This instruction copies the contents of the source \n            M, Rs                      register into the destination register; the contents of \n            Rd, M                      the source register are not altered. If one of the operands is a \n                                       memory location, its location is specified by the contents of \n                                       the HL registers. \n                                       Example:  MOV B, C      or  MOV B, M \n\nMove immediate 8-bit \nMVI         Rd, data                   The 8-bit data is stored in the destination register or \n            M, data                    memory.    If the operand is a memory location, its location is \n                                       specified by the contents of the HL registers. \n                                       Example:  MVI B, 57H  or  MVI M, 57H \n\nLoad accumulator \nLDA         16-bit address             The contents of a memory location, specified by a \n                                       16-bit address in the operand, are copied to the accumulator. \n                                       The contents of the source are not altered. \n                                       Example:  LDA 2034H \n\nLoad accumulator indirect \nLDAX        B/D Reg. pair              The contents of the designated register pair point to a memory \n                                       location. This instruction copies the contents of that memory \n                                       location  into  the  accumulator.   The  contents  of  either  the \n                                       register pair or the memory location are not altered. \n                                       Example:  LDAX B \n\nLoad register pair immediate \nLXI         Reg. pair, 16-bit data     The   instruction   loads  16-bit  data   in the  register   pair \n                                       designated in the operand. \n                                       Example:  LXI H, 2034H      or  LXI H, XYZ \n\nLoad H and L registers direct \nLHLD        16-bit address             The  instruction  copies the  contents  of the  memory  location \n                                       pointed  out by the  16-bit address into register L  and copies \n                                       the contents of the next memory location into register H.    The \n                                       contents of source memory locations are not altered. \n                                       Example:  LHLD 2040H \n\nStore accumulator direct \nSTA         16-bit address              The contents of the accumulator are copied into the memory \n                                        location specified by the operand.    This is a 3-byte instruction, \n                                        the second byte specifies the low-order address and the third \n                                        byte specifies the high-order address. \n                                        Example:  STA 4350H \n\nStore accumulator indirect \nSTAX        Reg. pair                   The contents of the accumulator are copied into the memory \n                                        location  specified  by  the  contents  of  the  operand  (register \n                                        pair).  The contents of the accumulator are not altered. \n                                        Example:  STAX B \n\nStore H and L registers direct \nSHLD        16-bit address              The contents of register L are stored into the memory location \n                                        specified by the 16-bit address in the operand and the contents \n                                        of  H  register  are  stored  into  the  next  memory  location  by \n                                        incrementing the operand.      The contents of registers HL are \n                                        not  altered.  This  is  a  3-byte  instruction,  the  second  byte \n                                        specifies the low-order address and the third byte specifies the \n                                        high-order address. \n                                        Example:  SHLD 2470H \n\nExchange H and L with D and E \nXCHG        none                        The contents of register H are exchanged with the contents of \n                                        register D, and the contents of register L are exchanged with \n                                        the contents of register E. \n                                        Example:  XCHG \n\nCopy H and L registers to the stack pointer \nSPHL        none                        The instruction loads the contents of the H and L registers into \n                                        the  stack  pointer  register,  the contents   of  the H  register \n                                        provide  the  high-order  address  and  the  contents  of  the  L \n                                        register provide the low-order address.    The contents of the H \n                                        and L registers are not altered. \n                                        Example:  SPHL \n\nExchange H and L with top of stack \nXTHL        none                        The contents of the L register  are exchanged with the  stack \n                                        location  pointed   out  by  the contents  of  the  stack  pointer \n                                        register.  The contents of the H register  are exchanged with \n                                        the next  stack location (SP+1); however, the contents of the \n                                        stack pointer register are not altered. \n                                        Example:  XTHL \n\nPush register pair onto stack \nPUSH        Reg. pair                   The contents of the register pair designated in the operand are \n                                        copied onto the  stack in the  following sequence.      The stack \n                                        pointer register is decremented and the contents of the high- \n                                        order register (B, D, H, A) are copied into that location.     The \n                                        stack pointer register is decremented again and the contents of \n                                        the  low-order  register   (C,  E,  L,  flags)  are  copied  to  that \n                                        location. \n                                        Example:  PUSH B or PUSH A \n\nPop off stack to register pair \nPOP         Reg. pair                   The contents of the memory location pointed out by the stack \n                                        pointer register are copied to the low-order register (C, E, L, \n                                        status flags) of the operand.   The stack pointer is incremented \n                                        by  1 and the contents of that memory location are copied to \n                                        the high-order register (B, D, H, A) of the operand.     The stack \n                                        pointer register is again incremented by 1. \n                                        Example:  POP H or POP A \n\nOutput data from accumulator to a port with 8-bit address \nOUT         8-bit port address          The contents of the accumulator are copied into the I/O port \n                                        specified by the operand. \n                                        Example:  OUT F8H \n\nInput data to accumulator from a port with 8-bit address \nIN          8-bit port address          The contents of the input port  designated in the operand are \n                                        read and loaded into the accumulator. \n                                        Example:  IN 8CH \n"); // NOI18N
        jTextArea1.setName("jTextArea1"); // NOI18N
        jScrollPane1.setViewportView(jTextArea1);

        jTabbedPane2.addTab("DATA TRANSFER INSTRUCTIONS ", jScrollPane1);

        jScrollPane2.setName("jScrollPane2"); // NOI18N

        jTextArea2.setColumns(20);
        jTextArea2.setEditable(false);
        jTextArea2.setFont(new java.awt.Font("Monospaced", 1, 13));
        jTextArea2.setLineWrap(true);
        jTextArea2.setRows(5);
        jTextArea2.setText("Opcode      Operand                      Description \n\nAdd register or memory to accumulator \nADD         R                            The contents of the operand (register or memory) are \n            M                            added  to  the  contents  of  the  accumulator  and  the  result  is \n                                         stored  in  the  accumulator.      If the  operand    is a  memory \n                                         location,  its  location  is  specified by  the  contents  of the  HL \n                                         registers.  All  flags are modified  to  reflect  the result  of the \n                                         addition. \n                                         Example:  ADD B  or  ADD M \n\nAdd register to accumulator with carry \nADC         R                            The contents of the operand (register or memory) and \n            M                            the  Carry flag are added to the  contents of the  accumulator \n                                         and the result is stored in the accumulator.     If the operand is a \n                                         memory location, its location is specified by the contents of \n                                         the HL registers.   All flags are modified to reflect the result of \n                                         the addition. \n                                         Example:  ADC B or ADC M \n\nAdd immediate to accumulator \nADI         8-bit data                   The   8-bit  data  (operand)  is  added  to  the   contents  of  the \n                                         accumulator and the result is stored in the accumulator.         All \n                                         flags are modified to reflect the result of the addition. \n                                         Example:  ADI  45H \n\nAdd immediate to accumulator with carry \nACI         8-bit data                   The 8-bit data (operand) and the Carry flag are added to the \n                                         contents  of  the  accumulator  and  the  result  is  stored  in  the \n                                         accumulator.    All flags are modified to reflect the result of the \n                                         addition. \n                                         Example:  ACI  45H \n\nAdd register pair to H and L registers \nDAD         Reg. pair                    The  16-bit contents of the specified register pair are added to \n                                         the contents of the HL register and the  sum is        stored in the \n                                         HL register.    The contents of the source register pair are not \n                                         altered.  If the result is larger than  16 bits, the CY flag is set. \n                                         No other flags are affected. \n                                         Example:  DAD H \n\nSubtract register or memory from accumulator \nSUB         R                            The contents of the operand (register or memory ) are \n            M                            subtracted from the contents of the accumulator, and the result \n                                         is  stored  in  the  accumulator.   If  the  operand  is  a  memory \n                                         location,  its  location  is  specified by  the  contents  of the  HL \n                                         registers.  All  flags are modified  to  reflect  the result  of the \n                                         subtraction. \n                                         Example:  SUB B  or  SUB M \n\nSubtract source and borrow from accumulator \nSBB         R                            The contents of the operand (register or memory ) and \n            M                            the  Borrow    flag  are  subtracted  from  the    contents  of  the \n                                         accumulator and the result is placed in the accumulator.           If \n                                         the operand is a memory location, its location is specified by \n                                         the  contents  of the  HL registers.    All  flags  are modified  to \n                                         reflect the result of the subtraction. \n                                         Example:  SBB B or SBB M \n\nSubtract immediate from accumulator \nSUI         8-bit data                   The 8-bit data (operand) is subtracted from the contents of the \n                                         accumulator and the result is stored in the accumulator.         All \n                                         flags are modified to reflect the result of the subtraction. \n                                         Example:  SUI  45H \n\nSubtract immediate from accumulator with borrow \nSBI         8-bit data                   The  8-bit data (operand) and the Borrow flag are subtracted \n                                         from the contents of the accumulator and the result is stored \n                                         in the accumulator.    All flags are modified to reflect the result \n                                         of the subtracion. \n                                         Example:  SBI  45H \n\nIncrement register or memory by 1 \nINR         R                            The contents of the designated register or memory) are \n            M                            incremented by  1 and the result is stored in the same place.      If \n                                         the operand is a memory location, its location is specified by \n                                         the contents of the HL registers. \n                                         Example:  INR B  or  INR M \n\nIncrement register pair by 1 \nINX         R                            The contents of the designated register pair  are incremented \n                                         by 1 and the result is stored in the same place. \n                                         Example:  INX H \n\nDecrement register or memory by 1 \nDCR         R                            The contents of the designated register or memory are \n            M                            decremented by  1 and the result is stored in the same place.      If \n                                         the operand is a memory location, its location is specified by \n                                         the contents of the HL registers. \n                                         Example:  DCR B  or  DCR M \n\nDecrement register pair by 1 \nDCX         R                            The contents of the designated register pair are decremented \n                                         by 1 and the result is stored in the same place. \n                                         Example:  DCX H \n\nDecimal adjust accumulator \nDAA         none                         The  contents  of the  accumulator  are  changed  from a binary \n                                         value to two 4-bit binary coded decimal (BCD) digits.        This is \n                                         the only instruction that uses the auxiliary flag to perform the \n                                         binary  to BCD  conversion, and the  conversion procedure  is \n                                         described below.     S, Z, AC, P, CY flags are altered to reflect \n                                         the results of the operation. \n\n                                         If  the  value  of  the  low-order  4-bits  in  the  accumulator  is \n                                         greater than 9 or if AC flag is set, the instruction adds 6 to the \n                                         low-order four bits. \n\n                                         If  the  value  of  the  high-order  4-bits  in  the  accumulator  is \n                                         greater than 9 or if the Carry flag is set, the instruction adds 6 \n                                         to the high-order four bits. \n\n                                         Example:  DAA \n");
        jTextArea2.setName("jTextArea2"); // NOI18N
        jScrollPane2.setViewportView(jTextArea2);

        jTabbedPane2.addTab("ARITHMETIC INSTRUCTIONS ", jScrollPane2);

        jScrollPane3.setName("jScrollPane3"); // NOI18N

        jTextArea3.setColumns(20);
        jTextArea3.setEditable(false);
        jTextArea3.setFont(new java.awt.Font("Monospaced", 1, 13));
        jTextArea3.setRows(5);
        jTextArea3.setText("Opcode     Operand                    Description \n\nJump unconditionally \nJMP         16-bit address            The program  sequence is transferred to the memory location \n                                      specified by the 16-bit address given in the operand. \n                                      Example:  JMP 2034H  or JMP XYZ \n\nJump conditionally \n\n    Operand:  16-bit address \n\n                                      The program  sequence is transferred to the memory location \n                                      specified by the  16-bit address given in the operand based on \n                                      the specified flag of the PSW as described below. \n                                      Example:  JZ 2034H  or JZ XYZ \n\n    Opcode           Description             Flag Status \n      JC             Jump on Carry             CY = 1 \n      JNC            Jump on no Carry          CY = 0 \n      JP             Jump on positive          S = 0 \n      JM             Jump on minus             S = 1 \n      JZ             Jump on zero              Z = 1 \n      JNZ            Jump on no zero           Z = 0 \n      JPE            Jump on parity even       P = 1 \n      JPO            Jump on parity odd        P = 0 \n\n\nUnconditional subroutine call \nCALL        16-bit address             The program  sequence is transferred to the memory location \n                                       specified by the  16-bit address given in the operand.    Before \n                                       the  transfer, the  address of the next  instruction  after CALL \n                                       (the contents of the program counter) is pushed onto the stack. \n                                       Example:  CALL 2034H  or CALL XYZ \n\nCall conditionally \n\n    Operand:   16-bit address \n\n                                       The program  sequence is transferred to the memory location \n                                       specified by the  16-bit address given in the operand based on \n                                       the specified flag of the PSW as described below.     Before the \n                                       transfer, the address of the next instruction after the call (the \n                                       contents of the program counter) is pushed onto the stack. \n                                       Example:  CZ 2034H  or CZ XYZ \n\n    Opcode           Description               Flag Status \n      CC             Call on Carry               CY = 1 \n      CNC            Call on no Carry            CY = 0 \n      CP             Call on positive            S = 0 \n      CM             Call on minus               S = 1 \n      CZ             Call on zero                Z = 1 \n      CNZ            Call on no zero             Z = 0 \n      CPE            Call on parity even         P = 1 \n      CPO            Call on parity odd          P = 0 \n\n\nReturn from subroutine unconditionally \nRET        none                      The program  sequence is transferred  from the  subroutine to \n                                     the calling program.  The two bytes from the top of the stack \n                                     are copied into the program  counter, and program  execution \n                                     begins at the new address. \n                                     Example:  RET \n\nReturn from subroutine conditionally \n\n    Operand:  none \n\n                                     The program  sequence is transferred  from the  subroutine to \n                                     the calling program based on the specified flag of the PSW as \n                                     described below.  The two bytes from the top of the stack are \n                                     copied  into  the  program counter,  and  program   execution \n                                     begins at the new address. \n                                     Example:  RZ \n\n    Opcode          Description             Flag Status \n      RC            Return on Carry           CY = 1 \n      RNC           Return on no Carry        CY = 0 \n      RP            Return on positive        S = 0 \n      RM            Return on minus           S = 1 \n      RZ            Return on zero            Z = 1 \n      RNZ           Return on no zero         Z = 0 \n      RPE           Return on parity even     P = 1 \n      RPO           Return on parity odd      P = 0 \n\n\nLoad program counter with HL contents \nPCHL        none                       The contents of registers H and L are copied into the program \n                                       counter.  The contents of H are placed as the high-order byte \n                                       and the contents of L as the low-order byte. \n                                       Example:  PCHL \n\nRestart \nRST         0-7                        The RST instruction is equivalent to a  1-byte call instruction \n                                       to one of eight memory locations depending upon the number. \n                                       The   instructions  are  generally   used  in  conjunction   with \n                                       interrupts  and  inserted  using  external  hardware.   However \n                                       these  can be  used  as  software  instructions  in  a program  to \n                                       transfer program execution to one of the eight locations.     The \n                                       addresses are: \n\n                                           Instruction           Restart Address \n                                              RST 0                  0000H \n                                              RST 1                  0008H \n                                              RST 2                  0010H \n                                              RST 3                  0018H \n                                              RST 4                  0020H \n                                              RST 5                  0028H \n                                              RST 6                  0030H \n                                              RST 7                  0038H \n\n                                       The  8085 has  four additional interrupts and these  interrupts \n                                       generate RST instructions internally and thus do not require \n                                       any external hardware.     These instructions and their Restart \n                                       addresses are: \n\n                                             Interrupt           Restart Address \n                                              TRAP                   0024H \n                                              RST 5.5                002CH \n                                              RST 6.5                0034H \n                                              RST 7.5                003CH \n");
        jTextArea3.setName("jTextArea3"); // NOI18N
        jScrollPane3.setViewportView(jTextArea3);

        jTabbedPane2.addTab("BRANCHING INSTRUCTIONS ", jScrollPane3);

        jScrollPane4.setName("jScrollPane4"); // NOI18N

        jTextArea4.setColumns(20);
        jTextArea4.setEditable(false);
        jTextArea4.setFont(new java.awt.Font("Monospaced", 1, 13));
        jTextArea4.setRows(5);
        jTextArea4.setText("Opcode       Operand                     Description \n\nCompare register or memory with accumulator \nCMP         R                             The contents of the operand (register or memory) are \n            M                             compared    with   the  contents    of  the  accumulator.      Both \n                                          contents  are  preserved    .  The  result  of  the  comparison  is \n                                          shown by setting the flags of the PSW as follows: \n                                          if (A) < (reg/mem):  carry flag is set \n                                          if (A) = (reg/mem):  zero flag is set \n                                          if (A) > (reg/mem):  carry and zero flags are reset \n                                         Example:  CMP B        or  CMP M \n\nCompare immediate with accumulator \nCPI          8-bit data                   The second byte (8-bit data) is compared with the contents of \n                                         the   accumulator.       The   values   being   compared     remain \n                                         unchanged.     The result of the comparison is shown by setting \n                                         the flags of the PSW as follows: \n                                          if (A) < data:  carry flag is set \n                                          if (A) = data:  zero flag is set \n                                          if (A) > data:  carry and zero flags are reset \n                                         Example:  CPI 89H \n\nLogical AND register or memory with accumulator \nANA         R                             The contents of the accumulator are logically ANDed with \n            M                            the  contents  of  the  operand  (register  or  memory),  and  the \n                                         result  is  placed  in  the  accumulator.      If  the operand  is   a \n                                         memory  location, its address is  specified by the  contents of \n                                         HL registers.    S, Z, P are modified to reflect the result of the \n                                          operation.  CY is reset.  AC is set. \n                                         Example:  ANA B or ANA M \n\nLogical AND immediate with accumulator \nANI          8-bit data                   The contents of the accumulator are logically ANDed with the \n                                          8-bit  data   (operand)    and   the   result   is placed    in  the \n                                          accumulator.    S, Z, P are modified to reflect the result of the \n                                          operation.  CY is reset.  AC is set. \n                                         Example:  ANI 86H \n\nExclusive OR register or memory with accumulator \nXRA         R                          The contents of the accumulator are Exclusive ORed with \n            M                          the  contents  of  the  operand  (register  or  memory),  and  the \n                                      result  is  placed in  the accumulator.    If  the operand  is  a \n                                       memory  location, its address is  specified by the  contents of \n                                       HL registers.  S, Z, P are modified to reflect the result of the \n                                       operation.  CY and AC are reset. \n                                       Example:  XRA B or XRA M \n\nExclusive OR immediate with accumulator \nXRI         8-bit data                 The contents of the accumulator are Exclusive ORed with the \n                                       8-bit  data  (operand)   and   the  result  is  placed   in  the \n                                       accumulator.   S, Z, P are modified to reflect the result of the \n                                       operation.  CY and AC are reset. \n                                       Example:  XRI 86H \n\nLogical OR register or memory with accumulaotr \nORA         R                          The contents of the accumulator are logically ORed with \n            M                          the  contents  of  the  operand  (register  or  memory),  and  the \n                                      result  is  placed in  the accumulator.    If  the operand  is  a \n                                       memory  location, its address is  specified by the  contents of \n                                       HL registers.  S, Z, P are modified to reflect the result of the \n                                       operation.  CY and AC are reset. \n                                       Example:  ORA B or ORA M \n\nLogical OR immediate with accumulator \nORI         8-bit data                 The contents of the accumulator are logically ORed with the \n                                       8-bit  data  (operand)   and   the  result  is  placed   in  the \n                                       accumulator.   S, Z, P are modified to reflect the result of the \n                                       operation.  CY and AC are reset. \n                                       Example:  ORI 86H \n\nRotate accumulator left \nRLC         none                       Each  binary  bit  of  the  accumulator  is  rotated  left  by  one \n                                      position.  Bit D7 is placed in the position of D0 as well as in \n                                       the Carry flag. CY is modified according to bit D7.     S, Z, P, \n                                       AC are not affected. \n                                       Example:  RLC \n\nRotate accumulator right \nRRC         none                       Each  binary  bit  of  the  accumulator  is  rotated  right  by  one \n                                      position.  Bit D0 is placed in the position of D7 as well as in \n                                       the Carry flag. CY is modified according to bit D0.     S, Z, P, \n                                       AC are not affected. \n                                       Example:  RRC \n\n\nRotate accumulator left through carry \nRAL         none                         Each  binary  bit  of  the  accumulator  is  rotated  left  by  one \n                                         position through the Carry flag.     Bit D7 is placed in the Carry \n                                         flag,  and  the  Carry  flag  is  placed  in  the  least  significant \n                                         position D0.  CY is modified according to bit D7.       S, Z, P, AC \n                                         are not affected. \n                                         Example:  RAL \n\nRotate accumulator right through carry \nRAR         none                         Each  binary  bit  of  the  accumulator  is  rotated  right  by  one \n                                         position through the Carry flag.     Bit D0 is placed in the Carry \n                                         flag,  and  the  Carry  flag  is  placed  in  the  most  significant \n                                         position D7.  CY is modified according to bit D0.       S, Z, P, AC \n                                         are not affected. \n                                         Example:  RAR \n\nComplement accumulator \nCMA         none                         The contents of the accumulator are complemented.          No flags \n                                         are affected. \n                                         Example:  CMA \n\nComplement carry \nCMC         none                         The Carry flag is complemented.  No other flags are affected. \n                                         Example:  CMC \n\nSet Carry \nSTC         none                         The Carry flag is set to 1.  No other flags are affected. \n                                         Example:  STC \n");
        jTextArea4.setName("jTextArea4"); // NOI18N
        jScrollPane4.setViewportView(jTextArea4);

        jTabbedPane2.addTab("LOGICAL INSTRUCTIONS ", jScrollPane4);

        jScrollPane5.setName("jScrollPane5"); // NOI18N

        jTextArea5.setColumns(20);
        jTextArea5.setEditable(false);
        jTextArea5.setFont(new java.awt.Font("Monospaced", 1, 13)); // NOI18N
        jTextArea5.setText("Opcode      Operand                     Description \n\nNo operation \nNOP         none                        No  operation  is performed.     The  instruction  is  fetched  and \n                                        decoded.  However no operation is executed. \n                                        Example:  NOP \n\nHalt and enter wait state \nHLT         none                        The CPU finishes executing the current instruction and halts \n                                        any further execution.     An  interrupt or reset  is necessary to \n                                        exit from the halt state. \n                                        Example:  HLT \n\nDisable interrupts \nDI          none                        The  interrupt  enable  flip-flop  is reset  and  all the  interrupts \n                                        except the TRAP are disabled.  No flags are affected. \n                                        Example:  DI \n\nEnable interrupts \nEI          none                        The  interrupt  enable  flip-flop  is  set  and  all  interrupts  are \n                                        enabled.   No  flags are affected.    After  a system reset  or the \n                                        acknowledgement  of  an  interrupt,  the  interrupt  enable  flip- \n                                        flop is reset, thus disabling the interrupts.   This instruction is \n                                        necessary to reenable the interrupts (except TRAP). \n                                        Example:  EI \n\nRead interrupt mask \nRIM          none                         This is a multipurpose  instruction used to read the  status of \n                                          interrupts  7.5,  6.5,  5.5  and  read  serial  data  input  bit. The \n                                          instruction   loads   eight  bits  in  the  accumulator     with  the \n                                          following interpretations. \n                                          Example:  RIM \n\nSet interrupt mask \nSIM          none                         This is a multipurpose instruction and used to implement the \n                                          8085  interrupts  7.5,  6.5,  5.5,  and  serial  data  output.   The \n                                          instruction interprets the accumulator contents as follows. \n                                          Example:  SIM \n");
        jTextArea5.setName("jTextArea5"); // NOI18N
        jScrollPane5.setViewportView(jTextArea5);

        jTabbedPane2.addTab("CONTROL INSTRUCTIONS ", jScrollPane5);

        jButton1.setText("OK");
        jButton1.setName("jButton1"); // NOI18N
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(523, 523, 523)
                .addComponent(jLabel1)
                .addContainerGap())
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jTabbedPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 1090, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap(544, Short.MAX_VALUE)
                .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 107, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(459, 459, 459))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(16, 16, 16)
                .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 14, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jTabbedPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 593, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jButton1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        dispose();
    }//GEN-LAST:event_jButton1ActionPerformed

    /**
    * @param args the command line arguments
    */
    public static void main(String args[]) {
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Help().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JScrollPane jScrollPane4;
    private javax.swing.JScrollPane jScrollPane5;
    private javax.swing.JTabbedPane jTabbedPane2;
    private javax.swing.JTextArea jTextArea1;
    private javax.swing.JTextArea jTextArea2;
    private javax.swing.JTextArea jTextArea3;
    private javax.swing.JTextArea jTextArea4;
    private javax.swing.JTextArea jTextArea5;
    // End of variables declaration//GEN-END:variables

}
